"""
This type stub file was generated by pyright.
"""

import sys
import os
import abc
from typing import Any, Optional

"""
Python 3.X compatibility tools.

While this file was originally intented for Python 2 -> 3 transition,
it is now used to create a compatibility layer between different
minor versions of Python 3.

While the active version of numpy may not support a given version of python, we
allow downstream libraries to continue to use these shims for forward
compatibility with numpy while they transition their code to newer versions of
Python.
"""
__all__ = ['bytes', 'asbytes', 'isfileobj', 'getexception', 'strchar', 'unicode', 'asunicode', 'asbytes_nested', 'asunicode_nested', 'asstr', 'open_latin1', 'long', 'basestring', 'sixu', 'integer_types', 'is_pathlib_path', 'npy_load_module', 'Path', 'pickle', 'contextlib_nullcontext', 'os_fspath', 'os_PathLike']
if sys.version_info[0] >= 3:
    long = int
    integer_types = (int, )
    basestring = str
    unicode = str
    bytes = bytes
    def asunicode(s):
        ...
    
    def asbytes(s):
        ...
    
    def asstr(s):
        ...
    
    def isfileobj(f):
        ...
    
    def open_latin1(filename, mode=...):
        ...
    
    def sixu(s):
        ...
    
    strchar = 'U'
else:
    ...
def getexception():
    ...

def asbytes_nested(x):
    ...

def asunicode_nested(x):
    ...

def is_pathlib_path(obj):
    """
    Check whether obj is a pathlib.Path object.

    Prefer using `isinstance(obj, os_PathLike)` instead of this function.
    """
    ...

class contextlib_nullcontext(object):
    """Context manager that does no additional processing.

    Used as a stand-in for a normal context manager, when a particular
    block of code is only sometimes used with a normal context manager:

    cm = optional_cm if condition else nullcontext()
    with cm:
        # Perform operation, using optional_cm if condition is True
    """
    def __init__(self, enter_result: Optional[Any] = ...):
        self.enter_result = ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *excinfo):
        ...
    


if sys.version_info[0] >= 3 and sys.version_info[1] >= 4:
    def npy_load_module(name, fn, info: Optional[Any] = ...):
        """
        Load a module.

        .. versionadded:: 1.11.2

        Parameters
        ----------
        name : str
            Full module name.
        fn : str
            Path to module file.
        info : tuple, optional
            Only here for backward compatibility with Python 2.*.

        Returns
        -------
        mod : module

        """
        ...
    
else:
    def npy_load_module(name, fn, info: Optional[Any] = ...):
        """
        Load a module.

        .. versionadded:: 1.11.2

        Parameters
        ----------
        name : str
            Full module name.
        fn : str
            Path to module file.
        info : tuple, optional
            Information as returned by `imp.find_module`
            (suffix, mode, type).

        Returns
        -------
        mod : module

        """
        ...
    
if sys.version_info[: 2] >= (3, 4):
    abc_ABC = abc.ABC
else:
    abc_ABC = abc.ABCMeta('ABC', (object, ), { '__slots__': () })
if sys.version_info[: 2] >= (3, 6):
    os_fspath = os.fspath
    os_PathLike = os.PathLike
else:
    def _PurePath__fspath__(self):
        ...
    
    class os_PathLike(abc_ABC):
        """Abstract base class for implementing the file system path protocol."""
        @abc.abstractmethod
        def __fspath__(self):
            """Return the file system path representation of the object."""
            ...
        
        @classmethod
        def __subclasshook__(cls, subclass):
            ...
        
    
    
    def os_fspath(path):
        """Return the path representation of a path-like object.
        If str or bytes is passed in, it is returned unchanged. Otherwise the
        os.PathLike interface is used to get the path representation. If the
        path representation is not str or bytes, TypeError is raised. If the
        provided path is not str, bytes, or os.PathLike, TypeError is raised.
        """
        ...
    
