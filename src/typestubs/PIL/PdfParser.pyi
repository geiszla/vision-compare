"""
This type stub file was generated by pyright.
"""

import collections
from typing import Any, Optional

def make_bytes(s):
    ...

def encode_text(s):
    ...

PDFDocEncoding = { 22: "\u0017",24: "\u02D8",25: "\u02C7",26: "\u02C6",27: "\u02D9",28: "\u02DD",29: "\u02DB",30: "\u02DA",31: "\u02DC",128: "\u2022",129: "\u2020",130: "\u2021",131: "\u2026",132: "\u2014",133: "\u2013",134: "\u0192",135: "\u2044",136: "\u2039",137: "\u203A",138: "\u2212",139: "\u2030",140: "\u201E",141: "\u201C",142: "\u201D",143: "\u2018",144: "\u2019",145: "\u201A",146: "\u2122",147: "\uFB01",148: "\uFB02",149: "\u0141",150: "\u0152",151: "\u0160",152: "\u0178",153: "\u017D",154: "\u0131",155: "\u0142",156: "\u0153",157: "\u0161",158: "\u017E",160: "\u20AC" }
def decode_text(b):
    ...

class PdfFormatError(RuntimeError):
    """An error that probably indicates a syntactic or semantic error in the
    PDF file structure"""
    ...


def check_format_condition(condition, error_message):
    ...

class IndirectReference(collections.namedtuple("IndirectReferenceTuple", ["object_id", "generation"])):
    def __str__(self):
        ...
    
    def __bytes__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __hash__(self):
        ...
    


class IndirectObjectDef(IndirectReference):
    def __str__(self):
        ...
    


class XrefTable:
    def __init__(self):
        self.existing_entries = ...
        self.new_entries = ...
        self.deleted_entries = ...
        self.reading_finished = ...
    
    def __setitem__(self, key, value):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __delitem__(self, key):
        ...
    
    def __contains__(self, key):
        ...
    
    def __len__(self):
        ...
    
    def keys(self):
        ...
    
    def write(self, f):
        ...
    


class PdfName:
    def __init__(self, name):
        ...
    
    def name_as_str(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __hash__(self):
        ...
    
    def __repr__(self):
        ...
    
    @classmethod
    def from_pdf_stream(cls, data):
        ...
    
    allowed_chars = ...
    def __bytes__(self):
        ...
    
    __str__ = ...


class PdfArray(list):
    def __bytes__(self):
        ...
    
    __str__ = ...


class PdfDict(collections.UserDict):
    def __setattr__(self, key, value):
        ...
    
    def __getattr__(self, key):
        ...
    
    def __bytes__(self):
        ...
    


class PdfBinary:
    def __init__(self, data):
        self.data = ...
    
    def __bytes__(self):
        ...
    


class PdfStream:
    def __init__(self, dictionary, buf):
        self.dictionary = ...
        self.buf = ...
    
    def decode(self):
        ...
    


def pdf_repr(x):
    ...

class PdfParser:
    """Based on
    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf
    Supports PDF up to 1.4
    """
    def __init__(self, filename: Optional[Any] = ..., f: Optional[Any] = ..., buf: Optional[Any] = ..., start_offset=..., mode=...):
        self.filename = ...
        self.buf = ...
        self.f = ...
        self.start_offset = ...
        self.should_close_buf = ...
        self.should_close_file = ...
        self.cached_objects = ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        ...
    
    def start_writing(self):
        ...
    
    def close_buf(self):
        self.buf = ...
    
    def close(self):
        ...
    
    def seek_end(self):
        ...
    
    def write_header(self):
        ...
    
    def write_comment(self, s):
        ...
    
    def write_catalog(self):
        self.root_ref = ...
        self.pages_ref = ...
    
    def rewrite_pages(self):
        self.orig_pages = ...
    
    def write_xref_and_trailer(self, new_root_ref: Optional[Any] = ...):
        self.last_xref_section_offset = ...
    
    def write_page(self, ref, *objs, **dict_obj):
        ...
    
    def write_obj(self, ref, *objs, **dict_obj):
        ...
    
    def del_root(self):
        ...
    
    @staticmethod
    def get_buf_from_file(f):
        ...
    
    def read_pdf_info(self):
        self.file_size_total = ...
        self.file_size_this = ...
        self.root_ref = ...
        self.info_ref = ...
        self.root = ...
        self.pages_ref = ...
        self.page_tree_root = ...
        self.pages = ...
        self.orig_pages = ...
    
    def next_object_id(self, offset: Optional[Any] = ...):
        ...
    
    delimiter = ...
    delimiter_or_ws = ...
    whitespace = ...
    whitespace_or_hex = ...
    whitespace_optional = ...
    whitespace_mandatory = ...
    newline_only = ...
    newline = ...
    re_trailer_end = ...
    re_trailer_prev = ...
    def read_trailer(self):
        self.last_xref_section_offset = ...
        self.trailer_dict = ...
        self.xref_table = ...
    
    def read_prev_trailer(self, xref_section_offset):
        ...
    
    re_whitespace_optional = ...
    re_name = ...
    re_dict_start = ...
    re_dict_end = ...
    @classmethod
    def interpret_trailer(cls, trailer_data):
        ...
    
    re_hashes_in_name = ...
    @classmethod
    def interpret_name(cls, raw, as_text: bool = ...):
        ...
    
    re_null = ...
    re_true = ...
    re_false = ...
    re_int = ...
    re_real = ...
    re_array_start = ...
    re_array_end = ...
    re_string_hex = ...
    re_string_lit = ...
    re_indirect_reference = ...
    re_indirect_def_start = ...
    re_indirect_def_end = ...
    re_comment = ...
    re_stream_start = ...
    re_stream_end = ...
    @classmethod
    def get_value(cls, data, offset, expect_indirect: Optional[Any] = ..., max_nesting=...):
        ...
    
    re_lit_str_token = ...
    escaped_chars = ...
    @classmethod
    def get_literal_string(cls, data, offset):
        ...
    
    re_xref_section_start = ...
    re_xref_subsection_start = ...
    re_xref_entry = ...
    def read_xref_table(self, xref_section_offset):
        ...
    
    def read_indirect(self, ref, max_nesting=...):
        ...
    
    def linearize_page_tree(self, node: Optional[Any] = ...):
        ...
    


