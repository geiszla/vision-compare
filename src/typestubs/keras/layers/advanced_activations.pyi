"""
This type stub file was generated by pyright.
"""

from ..engine.base_layer import Layer
from ..legacy import interfaces
from typing import Any, Optional

"""Layers that act as activation functions.
"""
class LeakyReLU(Layer):
    """Leaky version of a Rectified Linear Unit.

    It allows a small gradient when the unit is not active:
    `f(x) = alpha * x for x < 0`,
    `f(x) = x for x >= 0`.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        alpha: float >= 0. Negative slope coefficient.

    # References
        - [Rectifier Nonlinearities Improve Neural Network Acoustic Models](
           https://ai.stanford.edu/~amaas/papers/relu_hybrid_icml2013_final.pdf)
    """
    def __init__(self, alpha=..., **kwargs):
        self.supports_masking = ...
        self.alpha = ...
    
    def call(self, inputs):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class PReLU(Layer):
    """Parametric Rectified Linear Unit.

    It follows:
    `f(x) = alpha * x for x < 0`,
    `f(x) = x for x >= 0`,
    where `alpha` is a learned array with the same shape as x.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        alpha_initializer: initializer function for the weights.
        alpha_regularizer: regularizer for the weights.
        alpha_constraint: constraint for the weights.
        shared_axes: the axes along which to share learnable
            parameters for the activation function.
            For example, if the incoming feature maps
            are from a 2D convolution
            with output shape `(batch, height, width, channels)`,
            and you wish to share parameters across space
            so that each filter only has one set of parameters,
            set `shared_axes=[1, 2]`.

    # References
        - [Delving Deep into Rectifiers: Surpassing Human-Level Performance on
           ImageNet Classification](https://arxiv.org/abs/1502.01852)
    """
    @interfaces.legacy_prelu_support
    def __init__(self, alpha_initializer=..., alpha_regularizer: Optional[Any] = ..., alpha_constraint: Optional[Any] = ..., shared_axes: Optional[Any] = ..., **kwargs):
        self.supports_masking = ...
        self.alpha_initializer = ...
        self.alpha_regularizer = ...
        self.alpha_constraint = ...
    
    def build(self, input_shape):
        self.param_broadcast = ...
        self.alpha = ...
        self.input_spec = ...
        self.built = ...
    
    def call(self, inputs, mask: Optional[Any] = ...):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class ELU(Layer):
    """Exponential Linear Unit.

    It follows:
    `f(x) =  alpha * (exp(x) - 1.) for x < 0`,
    `f(x) = x for x >= 0`.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        alpha: scale for the negative factor.

    # References
        - [Fast and Accurate Deep Network Learning by Exponential Linear Units
           (ELUs)](https://arxiv.org/abs/1511.07289v1)
    """
    def __init__(self, alpha=..., **kwargs):
        self.supports_masking = ...
        self.alpha = ...
    
    def call(self, inputs):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class ThresholdedReLU(Layer):
    """Thresholded Rectified Linear Unit.

    It follows:
    `f(x) = x for x > theta`,
    `f(x) = 0 otherwise`.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        theta: float >= 0. Threshold location of activation.

    # References
        - [Zero-Bias Autoencoders and the Benefits of Co-Adapting Features](
           https://arxiv.org/abs/1402.3337)
    """
    def __init__(self, theta=..., **kwargs):
        self.supports_masking = ...
        self.theta = ...
    
    def call(self, inputs, mask: Optional[Any] = ...):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class Softmax(Layer):
    """Softmax activation function.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        axis: Integer, axis along which the softmax normalization is applied.
    """
    def __init__(self, axis=..., **kwargs):
        self.supports_masking = ...
        self.axis = ...
    
    def call(self, inputs):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class ReLU(Layer):
    """Rectified Linear Unit activation function.

    With default values, it returns element-wise `max(x, 0)`.

    Otherwise, it follows:
    `f(x) = max_value` for `x >= max_value`,
    `f(x) = x` for `threshold <= x < max_value`,
    `f(x) = negative_slope * (x - threshold)` otherwise.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as the input.

    # Arguments
        max_value: float >= 0. Maximum activation value.
        negative_slope: float >= 0. Negative slope coefficient.
        threshold: float. Threshold value for thresholded activation.
    """
    def __init__(self, max_value: Optional[Any] = ..., negative_slope=..., threshold=..., **kwargs):
        self.supports_masking = ...
        self.max_value = ...
        self.negative_slope = ...
        self.threshold = ...
    
    def call(self, inputs):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


