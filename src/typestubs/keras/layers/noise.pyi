"""
This type stub file was generated by pyright.
"""

from ..engine.base_layer import Layer
from ..legacy import interfaces
from typing import Any, Optional

"""Layers that operate regularization via the addition of noise.
"""
class GaussianNoise(Layer):
    """Apply additive zero-centered Gaussian noise.

    This is useful to mitigate overfitting
    (you could see it as a form of random data augmentation).
    Gaussian Noise (GS) is a natural choice as corruption process
    for real valued inputs.

    As it is a regularization layer, it is only active at training time.

    # Arguments
        stddev: float, standard deviation of the noise distribution.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as input.
    """
    @interfaces.legacy_gaussiannoise_support
    def __init__(self, stddev, **kwargs):
        self.supports_masking = ...
        self.stddev = ...
    
    def call(self, inputs, training: Optional[Any] = ...):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class GaussianDropout(Layer):
    """Apply multiplicative 1-centered Gaussian noise.

    As it is a regularization layer, it is only active at training time.

    # Arguments
        rate: float, drop probability (as with `Dropout`).
            The multiplicative noise will have
            standard deviation `sqrt(rate / (1 - rate))`.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as input.

    # References
        - [Dropout: A Simple Way to Prevent Neural Networks from Overfitting](
           http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)
    """
    @interfaces.legacy_gaussiandropout_support
    def __init__(self, rate, **kwargs):
        self.supports_masking = ...
        self.rate = ...
    
    def call(self, inputs, training: Optional[Any] = ...):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


class AlphaDropout(Layer):
    """Applies Alpha Dropout to the input.

    Alpha Dropout is a `Dropout` that keeps mean and variance of inputs
    to their original values, in order to ensure the self-normalizing property
    even after this dropout.
    Alpha Dropout fits well to Scaled Exponential Linear Units
    by randomly setting activations to the negative saturation value.

    # Arguments
        rate: float, drop probability (as with `Dropout`).
            The multiplicative noise will have
            standard deviation `sqrt(rate / (1 - rate))`.
        noise_shape: A 1-D `Tensor` of type `int32`, representing the
            shape for randomly generated keep/drop flags.
        seed: A Python integer to use as random seed.

    # Input shape
        Arbitrary. Use the keyword argument `input_shape`
        (tuple of integers, does not include the samples axis)
        when using this layer as the first layer in a model.

    # Output shape
        Same shape as input.

    # References
        - [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)
    """
    def __init__(self, rate, noise_shape: Optional[Any] = ..., seed: Optional[Any] = ..., **kwargs):
        self.rate = ...
        self.noise_shape = ...
        self.seed = ...
        self.supports_masking = ...
    
    def _get_noise_shape(self, inputs):
        ...
    
    def call(self, inputs, training: Optional[Any] = ...):
        ...
    
    def get_config(self):
        ...
    
    def compute_output_shape(self, input_shape):
        ...
    


