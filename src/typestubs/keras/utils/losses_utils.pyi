"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

"""Utilities related to losses."""
class Reduction(object):
    """Types of loss reduction.

    Contains the following values:

    * `NONE`: Un-reduced weighted losses with the same shape as input. When this
        reduction type used with built-in Keras training loops like
        `fit`/`evaluate`, the unreduced vector loss is passed to the optimizer but
        the reported loss will be a scalar value.
    * `SUM`: Scalar sum of weighted losses.
    * `SUM_OVER_BATCH_SIZE`: Scalar `SUM` divided by number of elements in losses.
    """
    NONE = ...
    SUM = ...
    SUM_OVER_BATCH_SIZE = ...
    @classmethod
    def all(cls):
        ...
    
    @classmethod
    def validate(cls, key):
        ...
    


def squeeze_or_expand_dimensions(y_pred, y_true: Optional[Any] = ..., sample_weight: Optional[Any] = ...):
    """Squeeze or expand last dimension if needed.

    1. Squeezes last dim of `y_pred` or `y_true` if their rank differs by 1.
    2. Squeezes or expands last dim of `sample_weight` if its rank differs by 1
    from the new rank of `y_pred`.
    If `sample_weight` is scalar, it is kept scalar.

    # Arguments
        y_pred: Predicted values, a `Tensor` of arbitrary dimensions.
        y_true: Optional label `Tensor` whose dimensions match `y_pred`.
        sample_weight: Optional weight scalar or `Tensor` whose dimensions match
            `y_pred`.

    # Returns
        Tuple of `y_pred`, `y_true` and `sample_weight`. Each of them possibly has
        the last dimension squeezed, `sample_weight` could be extended by one
        dimension.
    """
    ...

def _num_elements(losses):
    """Computes the number of elements in `losses` tensor."""
    ...

def reduce_weighted_loss(weighted_losses, reduction=...):
    """Reduces the individual weighted loss measurements."""
    ...

def broadcast_weights(values, sample_weight):
    ...

def compute_weighted_loss(losses, sample_weight: Optional[Any] = ..., reduction=..., name: Optional[Any] = ...):
    """Computes the weighted loss.

    # Arguments
        losses: `Tensor` of shape `[batch_size, d1, ... dN]`.
        sample_weight: Optional `Tensor` whose rank is either 0, or the same rank as
        `   losses`, or be broadcastable to `losses`.
        reduction: (Optional) Type of Reduction to apply to loss.
            Default value is `SUM_OVER_BATCH_SIZE`.
        name: Optional name for the op.

    # Raises
        ValueError: If the shape of `sample_weight` is not compatible with `losses`.

    # Returns
        Weighted loss `Tensor` of the same type as `losses`. If `reduction` is
            `NONE`, this has the same shape as `losses`; otherwise, it is scalar.
    """
    ...

