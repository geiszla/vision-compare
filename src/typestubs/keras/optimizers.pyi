"""
This type stub file was generated by pyright.
"""

from . import backend as K
from .legacy import interfaces
from typing import Any, Optional

"""Built-in optimizer classes.
"""
if K.backend() == 'tensorflow':
    ...
def clip_norm(g, c, n):
    """Clip the gradient `g` if the L2 norm `n` exceeds `c`.

    # Arguments
        g: Tensor, the gradient tensor
        c: float >= 0. Gradients will be clipped
            when their L2 norm exceeds this value.
        n: Tensor, actual norm of `g`.

    # Returns
        Tensor, the gradient clipped if required.
    """
    ...

class Optimizer(object):
    """Abstract optimizer base class.

    Note: this is the parent class of all optimizers, not an actual optimizer
    that can be used for training models.

    All Keras optimizers support the following keyword arguments:

        clipnorm: float >= 0. Gradients will be clipped
            when their L2 norm exceeds this value.
        clipvalue: float >= 0. Gradients will be clipped
            when their absolute value exceeds this value.
    """
    def __init__(self, **kwargs):
        self.updates = ...
        self.weights = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        ...
    
    def get_gradients(self, loss, params):
        ...
    
    def set_weights(self, weights):
        """Sets the weights of the optimizer, from Numpy arrays.

        Should only be called after computing the gradients
        (otherwise the optimizer has no weights).

        # Arguments
            weights: a list of Numpy arrays. The number
                of arrays and their shape must match
                number of the dimensions of the weights
                of the optimizer (i.e. it should match the
                output of `get_weights`).

        # Raises
            ValueError: in case of incompatible weight shapes.
        """
        ...
    
    def get_weights(self):
        """Returns the current value of the weights of the optimizer.

        # Returns
            A list of numpy arrays.
        """
        ...
    
    def get_config(self):
        ...
    
    @classmethod
    def from_config(cls, config):
        ...
    
    @property
    def lr(self):
        ...
    


class SGD(Optimizer):
    """Stochastic gradient descent optimizer.

    Includes support for momentum,
    learning rate decay, and Nesterov momentum.

    # Arguments
        learning_rate: float >= 0. Learning rate.
        momentum: float >= 0. Parameter that accelerates SGD
            in the relevant direction and dampens oscillations.
        nesterov: boolean. Whether to apply Nesterov momentum.
    """
    def __init__(self, learning_rate=..., momentum=..., nesterov: bool = ..., **kwargs):
        self.initial_decay = ...
        self.nesterov = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.updates = ...
        self.weights = ...
    
    def get_config(self):
        ...
    


class RMSprop(Optimizer):
    """RMSProp optimizer.

    It is recommended to leave the parameters of this optimizer
    at their default values
    (except the learning rate, which can be freely tuned).

    # Arguments
        learning_rate: float >= 0. Learning rate.
        rho: float >= 0.

    # References
        - [rmsprop: Divide the gradient by a running average of its recent magnitude
           ](http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
    """
    def __init__(self, learning_rate=..., rho=..., **kwargs):
        self.initial_decay = ...
        self.epsilon = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.weights = ...
        self.updates = ...
    
    def set_weights(self, weights):
        ...
    
    def get_config(self):
        ...
    


class Adagrad(Optimizer):
    """Adagrad optimizer.

    Adagrad is an optimizer with parameter-specific learning rates,
    which are adapted relative to how frequently a parameter gets
    updated during training. The more updates a parameter receives,
    the smaller the learning rate.

    It is recommended to leave the parameters of this optimizer
    at their default values.

    # Arguments
        learning_rate: float >= 0. Initial learning rate.

    # References
        - [Adaptive Subgradient Methods for Online Learning and Stochastic
           Optimization](http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)
    """
    def __init__(self, learning_rate=..., **kwargs):
        self.initial_decay = ...
        self.epsilon = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.weights = ...
        self.updates = ...
    
    def set_weights(self, weights):
        ...
    
    def get_config(self):
        ...
    


class Adadelta(Optimizer):
    """Adadelta optimizer.

    Adadelta is a more robust extension of Adagrad
    that adapts learning rates based on a moving window of gradient updates,
    instead of accumulating all past gradients. This way, Adadelta continues
    learning even when many updates have been done. Compared to Adagrad, in the
    original version of Adadelta you don't have to set an initial learning
    rate. In this version, initial learning rate and decay factor can
    be set, as in most other Keras optimizers.

    It is recommended to leave the parameters of this optimizer
    at their default values.

    # Arguments
        learning_rate: float >= 0. Initial learning rate, defaults to 1.
            It is recommended to leave it at the default value.
        rho: float >= 0. Adadelta decay factor, corresponding to fraction of
            gradient to keep at each time step.

    # References
        - [Adadelta - an adaptive learning rate method](
           https://arxiv.org/abs/1212.5701)
    """
    def __init__(self, learning_rate=..., rho=..., **kwargs):
        self.initial_decay = ...
        self.epsilon = ...
        self.rho = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.weights = ...
        self.updates = ...
    
    def set_weights(self, weights):
        ...
    
    def get_config(self):
        ...
    


class Adam(Optimizer):
    """Adam optimizer.

    Default parameters follow those provided in the original paper.

    # Arguments
        learning_rate: float >= 0. Learning rate.
        beta_1: float, 0 < beta < 1. Generally close to 1.
        beta_2: float, 0 < beta < 1. Generally close to 1.
        amsgrad: boolean. Whether to apply the AMSGrad variant of this
            algorithm from the paper "On the Convergence of Adam and
            Beyond".

    # References
        - [Adam - A Method for Stochastic Optimization](
           https://arxiv.org/abs/1412.6980v8)
        - [On the Convergence of Adam and Beyond](
           https://openreview.net/forum?id=ryQu7f-RZ)
    """
    def __init__(self, learning_rate=..., beta_1=..., beta_2=..., amsgrad: bool = ..., **kwargs):
        self.initial_decay = ...
        self.epsilon = ...
        self.amsgrad = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.updates = ...
        self.weights = ...
    
    def get_config(self):
        ...
    


class Adamax(Optimizer):
    """Adamax optimizer from Adam paper's Section 7.

    It is a variant of Adam based on the infinity norm.
    Default parameters follow those provided in the paper.

    # Arguments
        learning_rate: float >= 0. Learning rate.
        beta_1: float, 0 < beta < 1. Generally close to 1.
        beta_2: float, 0 < beta < 1. Generally close to 1.

    # References
        - [Adam - A Method for Stochastic Optimization](
           https://arxiv.org/abs/1412.6980v8)
    """
    def __init__(self, learning_rate=..., beta_1=..., beta_2=..., **kwargs):
        self.initial_decay = ...
        self.epsilon = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.updates = ...
        self.weights = ...
    
    def get_config(self):
        ...
    


class Nadam(Optimizer):
    """Nesterov Adam optimizer.

    Much like Adam is essentially RMSprop with momentum,
    Nadam is RMSprop with Nesterov momentum.

    Default parameters follow those provided in the paper.
    It is recommended to leave the parameters of this optimizer
    at their default values.

    # Arguments
        learning_rate: float >= 0. Learning rate.
        beta_1: float, 0 < beta < 1. Generally close to 1.
        beta_2: float, 0 < beta < 1. Generally close to 1.

    # References
        - [Nadam report](http://cs229.stanford.edu/proj2015/054_report.pdf)
        - [On the importance of initialization and momentum in deep learning](
           http://www.cs.toronto.edu/~fritz/absps/momentum.pdf)
    """
    def __init__(self, learning_rate=..., beta_1=..., beta_2=..., **kwargs):
        self.schedule_decay = ...
        self.epsilon = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.updates = ...
        self.weights = ...
    
    def set_weights(self, weights):
        ...
    
    def get_config(self):
        ...
    


class TFOptimizer(Optimizer):
    """Wrapper class for native TensorFlow optimizers.

    # Arguments
        optimizer: Selected optimizer
    """
    def __init__(self, optimizer):
        self.optimizer = ...
    
    @interfaces.legacy_get_updates_support
    @K.symbolic
    def get_updates(self, loss, params):
        self.updates = ...
    
    @property
    def weights(self):
        ...
    
    def get_config(self):
        ...
    
    @classmethod
    def from_config(cls, config):
        ...
    


sgd = SGD
rmsprop = RMSprop
adagrad = Adagrad
adadelta = Adadelta
adam = Adam
adamax = Adamax
nadam = Nadam
def serialize(optimizer):
    ...

def deserialize(config, custom_objects: Optional[Any] = ...):
    """Inverse of the `serialize` function.

    # Arguments
        config: Optimizer configuration dictionary.
        custom_objects: Optional dictionary mapping
            names (strings) to custom objects
            (classes and functions)
            to be considered during deserialization.

    # Returns
        A Keras Optimizer instance.
    """
    ...

def get(identifier):
    """Retrieves a Keras Optimizer instance.

    # Arguments
        identifier: Optimizer identifier, one of
            - String: name of an optimizer
            - Dictionary: configuration dictionary.
            - Keras Optimizer instance (it will be returned unchanged).
            - TensorFlow Optimizer instance
                (it will be wrapped as a Keras Optimizer).

    # Returns
        A Keras Optimizer instance.

    # Raises
        ValueError: If `identifier` cannot be interpreted.
    """
    ...

